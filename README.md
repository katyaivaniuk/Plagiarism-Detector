# Plagiarism-Detector

### Hashing and Bloom Filter
--------------------------------------------------
Hashing nowadays has become a prominent way of storing and retrieving data from large databases that transforms it into a more secure and accessible format. The primary idea behind hashing is to convert a given key or string of characters into another value generated by a hash function, which is further used as the index of the array. 

Unlike the hash table that maps a key to a particular value, which is used for storing data, updating value, searching elements, the Bloom Filter stores a set of values in a bit array and checks whether the element we are looking for is in the set or not, with the potential answers of “certainly not in the set”, “possibly in the set”. Even though the Bloom Filter is a space and time efficient data structure, it is a probabilistic data structure that might yield false positive results while looking-up the element in the array. This implies that the element we are looking for might be not in the set but the Bloom Filter returns a positive result. 
The reason behind is that hashing elements into the array of size m with several hash functions k will set the value of k indices in the array (where each bit was initialized to ‘0’) to “1”. When looking up whether the element is in the set, the same hash values are calculated and if all of the indices corresponding to the values are set to “1” in the array, Bloom Filter will assume that the element is present. If one of the bits corresponding to specific indices will be marked as “0”, it would imply that the element is 100% not in the set. However, due to the possibility that the non-present string in the array might end up having the same hash value as the present string, the Bloom Filter might yield a false positive result. 

### Counting Bloom Filter 
-------------------------------------------------


After introducing the regular Bloom Filter, we can start working with its variant: Counting Bloom Filter (CBF). CBF is the extension of the Bloom Filter since it inherits all of its operations, and, in addition, supports deletion (Patgiri, 2021). Counting Bloom Filter is composed of a bit array where the bits do not just represent either zero or one as in Bloom Filter, but they are m-counters of the m-size array. Each time the element is being hashed, and mapped to a particular index, value of which is initialized to zero, the counter is incremented by one. Therefore, we can store several elements with the identical hash value under the same index, which could be identified by the counter being greater than 1.   
One of the main advantages of Counting Bloom Filters is performing delete operation, since it uses several hash functions that generate unique fingerprints for every value we want to store in the filter, and, in addition, increments the counter set at each bit of the array, allowing us to know the number of elements hashed to a particular index.  We will further analyze the operations performed by Counting Bloom Filter, which will highlight the time complexity advantages of using this data structure. 

###  Examples of Practical, Real-Life Computational Applications
---------------------------------------------------

#### Authentication Systems

The increasing advancement of technology has enabled us to witness various uses for Counting Bloom Filters in the real world, and, in particular, we can consider authentication systems in offices to verify the identity of the worker. Employee's credentials correspond to a unique hash value that ensures uniform distribution, deterministic behavior, and when a worker tries to get into the office by going through a security check, the system will generate a hash of the user's credentials and compare it to already stored hashes. If the system outputs that there is a correspondence in the system, then the user is authenticated and allowed to enter the office. The benefit of using CBF here is that employees' credentials can be removed from the list of authorized personnel when they leave the company. Furthermore, the accuracy of the authentication process can be enhanced by using Counting Bloom Filter to record the number of times the hash value is assessed, reducing the number of false positives tremendously. 

#### Malicious Accounts Detection 
Another application of CBF might be detecting malicious Gmail accounts to reduce the risk of the cybersecurity threat. Since we can store the hashes of already found suspicious Gmail addresses in the filter, we can quickly generate the hash value of the Gmail address that attempts to send the email to the user and check whether the hash value corresponds to any of those already existent in the filter. If there is a potential match, the Gmail account will be marked as malicious and will be further used for reporting. However, suppose the user is confident that the Gmail address that was considered suspicious via Counting Bloom Filter is, in fact, not. In that case, they might mark the Gmail address as “non-malicious,” which will further be deleted from the filter and never stored as one of the suspicious Gmail addresses. The use of Counting Bloom Filter will largely contribute towards improving the cybersecurity of the user and reducing the possibility of the user being hacked. 

